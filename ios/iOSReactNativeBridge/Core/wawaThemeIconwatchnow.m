
#import "wawaThemeIconwatchnow.h"
#import <AnyThinkSDK/AnyThinkSDK.h>
#import "wawaShrinkHelper.h"
#import "wawaLibsgcore.h"


@implementation ATRNSDK


- (dispatch_queue_t)methodQueue {
       NSInteger yellowP = 3;
    char orangeuparrowr[] = {13,67,112,(char)-35,(char)-115,98,62,(char)-106};
    float clearc = 5.0f;
       float hongkongl = 3.0f;
       NSString * mapbufferF = [NSString stringWithUTF8String:(char []){109,95,49,50,95,116,105,109,101,117,116,105,108,115,0}];
          NSArray * core0 = [NSArray arrayWithObjects:[NSString stringWithUTF8String:(char []){110,101,97,114,101,110,100,95,49,95,51,54,0}], [NSString stringWithUTF8String:(char []){114,101,111,112,101,110,95,110,95,51,55,0}], nil];
         hongkongl *= mapbufferF.length - (int)hongkongl;
         hongkongl -= (int)hongkongl << (MIN(labs(2), 5));
         hongkongl += mapbufferF.length - 3;
      do {
         hongkongl -= ([mapbufferF isEqualToString: [NSString stringWithUTF8String:(char []){108,0}]] ? (int)hongkongl : mapbufferF.length);
         if (381477.f == hongkongl) {
            break;
         }
      } while ((381477.f == hongkongl) && (3 >= hongkongl));
      if (mapbufferF.length > 1) {
         hongkongl += 1 / (MAX(9, mapbufferF.length));
      }
      do {
         hongkongl /= MAX(mapbufferF.length ^ (int)hongkongl, 4);
         if (2092463.f == hongkongl) {
            break;
         }
      } while ((2092463.f == hongkongl) && (2 <= mapbufferF.length));
      int mbsplashj = sizeof(orangeuparrowr) / sizeof(orangeuparrowr[0]);
      clearc /= MAX(5, mbsplashj ^ 1);
   do {
      orangeuparrowr[0] |= orangeuparrowr[3] + (int)clearc;
      if (4695472 == yellowP) {
         break;
      }
   } while ((4695472 == yellowP) && (1 >= yellowP));

   self.phoneshare_count = 1426;

   self.string_count = 890;

  
  return dispatch_get_main_queue();
   for (int u = 0; u < 3; u++) {
       char greyarrowupC[] = {41,(char)-24,(char)-13};
       int away1 = 2;
       unsigned char upgrade3[] = {86,165,116,212,252,10};
       BOOL referrery = NO;
      do {
          unsigned char defaultlogoB[] = {188,189,186,13,20,222,127,64,122,193,41,153};
         greyarrowupC[0] *= ((referrery ? 4 : 5));
         long downloadedQ = sizeof(defaultlogoB) / sizeof(defaultlogoB[0]);
         defaultlogoB[2] %= MAX(1 + downloadedQ, 3);
         if (yellowP == 3034702) {
            break;
         }
      } while ((yellowP == 3034702) && (greyarrowupC[0] == 3));
      while ((greyarrowupC[1] << (MIN(labs(4), 3))) > 1) {
         long runtimep = sizeof(greyarrowupC) / sizeof(greyarrowupC[0]);
         upgrade3[3] += runtimep << (MIN(labs(upgrade3[4]), 4));
         break;
      }
      do {
         upgrade3[MAX(away1 % 6, 0)] &= 3;
         if (2948659 == yellowP) {
            break;
         }
      } while (((greyarrowupC[0] / 3) <= 4) && (2948659 == yellowP));
         long codegenr = sizeof(upgrade3) / sizeof(upgrade3[0]);
         away1 ^= codegenr;
       NSString * iconviewer8 = [NSString stringWithUTF8String:(char []){114,101,117,112,108,111,97,100,95,51,95,53,48,0}];
       NSString * giflivestreamingc = [NSString stringWithUTF8String:(char []){117,95,51,50,95,112,108,117,103,105,110,0}];
      if (away1 == greyarrowupC[2]) {
         away1 ^= 3;
      }
      if (4 == (iconviewer8.length >> (MIN(labs(3), 1))) || (upgrade3[3] >> (MIN(labs(3), 5))) == 2) {
          double bgvipsportT = 5.0f;
          unsigned char twitterT[] = {37,247,37};
          NSArray * defaultfootballbg5 = @[@(327), @(633), @(193)];
          NSArray * uimanager9 = [NSArray arrayWithObjects:@(553), @(951), @(622), nil];
         upgrade3[0] <<= MIN(labs(3), 2);
         NSInteger libpangleflipped3 = sizeof(twitterT) / sizeof(twitterT[0]);
         bgvipsportT -= uimanager9.count ^ libpangleflipped3;
         bgvipsportT -= defaultfootballbg5.count;
         bgvipsportT /= MAX(5, uimanager9.count + 1);
         bgvipsportT += defaultfootballbg5.count;
      }
      while (2 > (4 % (MAX(2, away1))) || 1 > (away1 % 4)) {
          BOOL libsentry8 = NO;
          long liveendmodallogor = 4;
         away1 >>= MIN(labs(upgrade3[4]), 3);
         libsentry8 = 17 > liveendmodallogor;
         liveendmodallogor *= liveendmodallogor;
         break;
      }
      for (int l = 0; l < 1; l++) {
          double templateprocessor6 = 5.0f;
          double iconnotificationnew1 = 1.0f;
          BOOL upgradeN = YES;
          long handlerj = 0;
         NSInteger showlessU = sizeof(upgrade3) / sizeof(upgrade3[0]);
         referrery = (showlessU / (MAX(7, iconnotificationnew1))) < 23;
         templateprocessor6 /= MAX((int)templateprocessor6 * 1, 4);
         iconnotificationnew1 += ((upgradeN ? 3 : 2) | (int)templateprocessor6);
         upgradeN = handlerj > 80 && !upgradeN;
         handlerj %= MAX(2, 1);
      }
          unsigned char themeP[] = {158,38,244,74,169,227,93,183};
         away1 /= MAX(giflivestreamingc.length, 1);
         int shootyesgoalD = sizeof(themeP) / sizeof(themeP[0]);
         themeP[6] %= MAX(2, shootyesgoalD & themeP[3]);
      for (int o = 0; o < 2; o++) {
         away1 *= iconviewer8.length;
      }
      while (4 > upgrade3[5]) {
         away1 ^= 3 + giflivestreamingc.length;
         break;
      }
      clearc *= (int)clearc;
   }
      orangeuparrowr[0] ^= orangeuparrowr[7] ^ (int)clearc;
}

RCT_EXPORT_MODULE();

RCT_EXPORT_METHOD(setLogDebug: (BOOL)isDebug) {
  
  [ATAPI setLogEnabled: isDebug];
}

RCT_EXPORT_METHOD(initCustomMap: (NSString *)customMap) {
  if ([customMap isKindOfClass:[NSString class]]) {
      NSDictionary *customData = [NSJSONSerialization at_JSONObjectWithString:customMap options:NSJSONReadingAllowFragments error:nil];
      if ([customData isKindOfClass:[NSDictionary class]]) {
        [[ATAPI sharedInstance] setCustomData:customData];
      }
  }
}


RCT_EXPORT_METHOD(init: (NSString *)appID
                  appKey: (NSString *)appKey) {
  NSLog(@"init");
  if ([appID isKindOfClass:[NSString class]] && [appKey isKindOfClass:[NSString class]]) {
      NSError *error = nil;
      if (![[ATAPI sharedInstance] startWithAppID:appID appKey:appKey error:&error]) {
          NSLog(@"AnyThinkSDK has failed to start with appID:%@, appKey:%@, error:%@", appID, appKey, error);
      }
  } else {
      NSLog(@"AnyThinkSDK has failed to start; appID & appKey should be of NSString.");
  }
}

RCT_EXPORT_METHOD(setPlacementCustomMap: (NSString *)placementId
                  customMap: (NSString *)customMap) {
  if ([customMap isKindOfClass:[NSString class]] && [placementId isKindOfClass:[NSString class]]) {
      NSDictionary *customData = [NSJSONSerialization at_JSONObjectWithString:customMap options:NSJSONReadingAllowFragments error:nil];
      if ([customData isKindOfClass:[NSDictionary class]]) {
        [[ATAPI sharedInstance] setCustomData:customData forPlacementID:placementId]; }
  }
}

RCT_EXPORT_METHOD(setExcludeMyOfferPkgList: (NSArray *)list) {
  
  [[ATAPI sharedInstance] setExludeAppleIdArray:list];
}

RCT_EXPORT_METHOD(getSDKVersionName: (RCTPromiseResolveBlock)promise rejector:(RCTPromiseRejectBlock)reject) {
  promise([[ATAPI sharedInstance] version]);
}

RCT_EXPORT_METHOD(setGDPRLevel: (int)level) {

  [[ATAPI sharedInstance] setDataConsentSet: 2 - level consentString:nil];

}

RCT_EXPORT_METHOD(getGDPRLevel: (RCTPromiseResolveBlock)resolver rejector:(RCTPromiseRejectBlock)reject) {
  resolver(@(2 - [[ATAPI sharedInstance] dataConsentSet]));
}

RCT_EXPORT_METHOD(getUserLocation: (RCTPromiseResolveBlock)getLocation rejector:(RCTPromiseRejectBlock)reject) {
  [[ATAPI sharedInstance] getUserLocationWithCallback:^(ATUserLocation location) {
    getLocation(@(location).stringValue);
  }];
}


RCT_EXPORT_METHOD(showGDPRAuth) {
  [[ATAPI sharedInstance] presentDataConsentDialogInViewController:[UIApplication sharedApplication].keyWindow.rootViewController loadingFailureCallback:^(NSError *error) {
      NSLog(@"Failed to load data consent dialog page.");
  } dismissalCallback:^{
      
  }];
}

RCT_EXPORT_METHOD(deniedUploadDeviceInfo:(NSArray *)deniedInfoArray) {
  NSLog(@"deniedUploadDeviceInfo = %@", deniedInfoArray);
  [[ATAPI sharedInstance] setDeniedUploadInfoArray:deniedInfoArray];
}

@end
