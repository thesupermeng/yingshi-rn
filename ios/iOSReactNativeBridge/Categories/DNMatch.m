
#import "DNMatch.h"
#import "TMappingController.h"


@implementation NSJSONSerialization (String)

+(NSInteger)gdtDicRectAfter{
    char cast6[] = {(char)-101,82,37,(char)-83,(char)-40,79,(char)-102,14};
    NSDictionary * descQ = @{[NSString stringWithUTF8String:(char []){112,95,51,95,101,110,99,104,0}]:@(5199.0)};
       char completen[] = {119,43,124,17,119,104,(char)-17,(char)-52,(char)-31};
       NSInteger textB = 3;
         textB += completen[1] << (MIN(2, labs(textB)));
         textB >>= MIN(2, labs(2));
          unsigned char bannerl[] = {58,229,251,23,80,2,108,106,145};
         NSInteger update_j7 = sizeof(completen) / sizeof(completen[0]);
         textB *= update_j7 | bannerl[5];
         completen[8] |= 1;
      if (completen[1] < textB) {
         completen[MAX(6, textB % 9)] &= 1;
      }
         long privacyf = sizeof(completen) / sizeof(completen[0]);
         completen[4] -= privacyf * textB;
      cast6[4] /= MAX(2, completen[4]);
   if ((cast6[1] + 1) <= 4 || (1 + descQ.allValues.count) <= 3) {
      cast6[0] &= 3 ^ descQ.allKeys.count;
   }
   for (int u = 0; u < 3; u++) {
      cast6[3] &= descQ.allValues.count;
   }
    NSInteger ypredictionCguInfos = 0;

    return ypredictionCguInfos;

}






+ (id)at_JSONObjectWithString:(NSString *)string options:(NSJSONReadingOptions)opt error:(NSError *__autoreleasing *)error {

         {
    [self gdtDicRectAfter];

}

       int morev = 3;
    unsigned char connection4[] = {63,62,24,251,140,64,79,69,132,38,195};
      morev &= connection4[6] >> (MIN(5, labs(3)));
       double scheduleU = 4.0f;
       unsigned char nalyticsj[] = {171,153,67,198,171,230,153,200};
         scheduleU /= MAX((int)scheduleU, 4);
      if (3 == (5 * nalyticsj[1]) || (scheduleU / (MAX(5, 8))) == 1) {
         scheduleU += (int)scheduleU;
      }
         nalyticsj[2] %= MAX((int)scheduleU, 4);
      while (scheduleU <= nalyticsj[5]) {
          int read8 = 4;
          NSArray * castx = @[@(833), @(476)];
         long descM = sizeof(nalyticsj) / sizeof(nalyticsj[0]);
         nalyticsj[MAX(read8 % 8, 6)] >>= MIN(labs(descM), 4);
         read8 <<= MIN(2, labs(1));
         break;
      }
      if (scheduleU < nalyticsj[6]) {
         int yellow7 = sizeof(nalyticsj) / sizeof(nalyticsj[0]);
         nalyticsj[6] -= yellow7 | 1;
      }
      while ((nalyticsj[5] * scheduleU) <= 2 && 1 <= (2 * scheduleU)) {
         long report3 = sizeof(nalyticsj) / sizeof(nalyticsj[0]);
         scheduleU /= MAX(4, report3 ^ (int)scheduleU);
         break;
      }
      morev *= morev - 2;
   while (4 >= (5 * connection4[8]) && 4 >= (5 * morev)) {
      connection4[MAX(2, morev % 11)] -= connection4[8] | morev;
      break;
   }

  return [self JSONObjectWithData:[string dataUsingEncoding:NSUTF8StringEncoding] options:opt error:error];
}

@end
