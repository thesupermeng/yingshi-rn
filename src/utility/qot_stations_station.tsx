import axios, { AxiosInstance, AxiosResponse } from 'axios';
import DeviceInfo from 'react-native-device-info';
import { KPDCanvasVietnamView } from './hw_theme_view';
import { SMBing } from './sa_crown';
import { WAnalyticsArrow } from './a_singapore';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { IHUpdateBanner } from '../constants';
import { KLongNext } from '../../z_search';
import { APP_NAME_CONST, APP_VERSION, UMENG_CHANNEL } from './n_subs_interstitial';
import { Platform } from 'react-native';

export class JTumbnailMatches {
    static #env = new KPDCanvasVietnamView(__DEV__ ? 'development' : 'production');
    static #apiInstance: AxiosInstance | null = null;
    static bearerToken: string;

    static init = async () => {
       let streamingE = String.fromCharCode(109,95,52,95,108,111,103,103,101,114,115,0);
    let short_s37 = 3.0;
    let bodanM: Map<any, any> = new Map([[String.fromCharCode(103,95,57,51,0),String.fromCharCode(114,101,97,100,108,110,95,119,95,54,56,0)], [String.fromCharCode(102,105,110,97,108,105,122,105,110,103,95,52,95,57,52,0),String.fromCharCode(118,95,51,49,95,118,105,115,105,98,108,105,116,121,0)], [String.fromCharCode(109,117,110,108,111,99,107,95,103,95,49,50,0),String.fromCharCode(106,112,101,103,116,97,98,108,101,115,95,101,95,52,56,0)]]);
    let typingI: Array<any> = [337, 775, 41];
    let bodanm: Array<any> = [String.fromCharCode(117,110,107,110,111,119,110,95,119,95,54,48,0), String.fromCharCode(101,118,97,108,117,97,116,111,114,95,122,95,55,48,0)];
    let champion2 = String.fromCharCode(97,108,108,95,49,95,55,54,0);
    let anythinkc = false;
    let crownu = String.fromCharCode(122,95,52,49,95,108,108,118,105,100,100,115,112,101,110,99,0);
    let acceptedc = 4.0;
      typingI = [2 << (Math.min(3, typingI.length))];

        if (__DEV__) {

      typingI.push(bodanm.length + bodanM.size);
            this.#env = new KPDCanvasVietnamView('development');
        } else {

      bodanM.set(streamingE, typingI.length ^ 2);
            this.#env = new KPDCanvasVietnamView('production');

      streamingE += `${bodanm.length >> (Math.min(Math.abs(2), 1))}`;
        }

        let deviceId = await DeviceInfo.getUniqueId();

      bodanM.set(streamingE, streamingE.length);
        if (typeof deviceId !== "string") {

   while ((streamingE.length << (Math.min(Math.abs(3), 3))) > 4 && (3 * streamingE.length) > 2) {
      streamingE += `${typingI.length - 1}`;
      break;
   }
            deviceId = JSON.stringify(deviceId);
        }

        this.#apiInstance = axios.create({
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json',
            },
            validateStatus: function () {
                return true;
            },
        });

   for (let n = 0; n < 3; n++) {
      bodanM.set(`${typingI.length}`, bodanm.length ^ typingI.length);
   }

        this.#apiInstance.interceptors.request.use(async (config) => {
            if (this.bearerToken === undefined) {

      streamingE = `${(streamingE == String.fromCharCode(53,0) ? bodanM.size : streamingE.length)}`;
                const token = await this.regetToken();

       let textY: Map<any, any> = new Map([[String.fromCharCode(113,95,56,57,95,99,111,114,112,117,115,0),762], [String.fromCharCode(108,95,56,50,95,108,105,99,101,110,115,101,0),11]]);
       let edita = String.fromCharCode(115,116,114,97,116,101,103,105,101,115,95,52,95,56,52,0);
       let smallS = String.fromCharCode(115,112,101,99,105,102,105,101,114,95,55,95,55,50,0);
       let scheduleK: Array<any> = [221, 224];
       let controlF: Array<any> = [String.fromCharCode(116,114,105,109,95,120,95,56,51,0), String.fromCharCode(98,95,50,95,115,113,108,105,116,101,114,98,117,0)];
      if (scheduleK.length < controlF.length) {
          let dangerk = String.fromCharCode(105,110,100,97,116,97,95,112,95,51,0);
          let select5 = String.fromCharCode(115,97,109,112,108,101,102,109,116,95,118,95,55,0);
          let goalp = false;
          let confirmationV = 4;
         controlF.push(2);
         dangerk += `${dangerk.length}`;
         select5 += `${select5.length * confirmationV}`;
         goalp = confirmationV <= 55;
      }
         controlF = [smallS.length];
      for (let u = 0; u < 1; u++) {
          let pressureu = String.fromCharCode(119,114,105,116,101,95,103,95,51,48,0);
          let nextR = 0.0;
          let referrer5 = 1;
         scheduleK = [controlF.length];
         pressureu = `${2 ^ pressureu.length}`;
         nextR -= 1 << (Math.min(3, Math.abs(parseInt(`${nextR}`))));
         referrer5 /= Math.max(2 - pressureu.length, 5);
      }
       let episodeH = String.fromCharCode(122,95,51,55,95,109,105,99,114,111,100,118,100,0);
       let moreV = String.fromCharCode(100,95,49,49,95,114,105,110,102,0);
       let middlewareG = String.fromCharCode(112,117,116,110,117,109,112,97,115,115,101,115,95,110,95,57,0);
      while (2 < (middlewareG.length ^ textY.size) || (2 ^ middlewareG.length) < 2) {
         textY = new Map([[moreV, middlewareG.length]]);
         break;
      }
      let bodanL = String.fromCharCode(105,110,121,53,113,102,122,98,51,104,0) == edita;
      do {
         edita += `${episodeH.length * 2}`;
         if (bodanL) {
            break;
         }
      } while ((moreV != String.fromCharCode(50,0) && edita != String.fromCharCode(85,0)) && bodanL);
          let away3 = String.fromCharCode(102,95,49,95,121,114,121,105,0);
         episodeH = "3";
         away3 = `${away3.length}`;
      anythinkc = smallS.length <= 55 || short_s37 <= 89.9;
                if (token) this.bearerToken = token;
            }

            

       let whistlex = false;
       let downloading5: Array<any> = [12, 562];
       let shirtb = 1.0;
         whistlex = !whistlex;
         downloading5.push((2 >> (Math.min(5, Math.abs((whistlex ? 3 : 5))))));
         shirtb /= Math.max(5, parseInt(`${shirtb}`) & downloading5.length);
         whistlex = downloading5.includes(whistlex);
      if (3.97 == (shirtb + 1.97)) {
          let infoe = 1;
          let storeO = false;
          let star0: Array<any> = [403, 417];
          let layouti = 5.0;
         shirtb += infoe;
         infoe ^= ((storeO ? 1 : 5) % (Math.max(parseInt(`${layouti}`), 2)));
         storeO = !storeO;
         star0.push(((storeO ? 3 : 4) << (Math.min(Math.abs(3), 1))));
         layouti -= parseFloat(`${3 + star0.length}`);
      }
      if ((downloading5.length % 1) >= 4) {
          let trashQ = 4.0;
          let stepb = String.fromCharCode(114,95,50,95,113,112,101,108,0);
         shirtb += parseInt(`${shirtb}`) ^ downloading5.length;
         trashQ -= parseFloat(`${stepb.length}`);
         stepb += `${stepb.length}`;
      }
       let regengz = false;
       let actionsc = false;
      let verticalA = whistlex ? !whistlex : whistlex;
      do {
         whistlex = !regengz;
         if (verticalA) {
            break;
         }
      } while ((!whistlex) && verticalA);
      for (let u = 0; u < 1; u++) {
          let register_1n: Array<any> = [718, 747];
          let cast_ = String.fromCharCode(115,95,50,56,95,115,99,97,108,101,109,111,100,101,0);
          let historyE = 3.0;
          let playlista = false;
         downloading5 = [((regengz ? 2 : 4) % (Math.max(3, 1)))];
         register_1n.push(register_1n.length);
         cast_ = `${(cast_ == String.fromCharCode(121,0) ? cast_.length : register_1n.length)}`;
         historyE *= parseFloat(`${register_1n.length / 3}`);
         playlista = !playlista || cast_.length >= 32;
      }
      champion2 = `${2 + typingI.length}`;
            if (config.url?.includes(this.#env.apiUrl)) {
                config.headers['Authorization'] = `Bearer ${this.bearerToken}`;

       let hejiy: Array<any> = [78, 148, 382];
       let description_g7N = String.fromCharCode(97,99,99,101,108,101,114,97,116,105,111,110,95,97,95,55,53,0);
         hejiy.push(description_g7N.length);
       let tickedO = String.fromCharCode(105,95,49,50,95,116,114,105,109,0);
       let fastforwardt = String.fromCharCode(106,112,101,103,95,52,95,50,50,0);
          let heartT = String.fromCharCode(112,114,101,102,101,116,99,104,101,114,95,50,95,51,48,0);
         tickedO += `${fastforwardt.length}`;
         heartT = "3";
         tickedO += `${description_g7N.length * 2}`;
         tickedO += `${description_g7N.length}`;
      for (let o = 0; o < 2; o++) {
         description_g7N = `${hejiy.length / (Math.max(3, 4))}`;
      }
      bodanM = new Map([[`${hejiy.length}`, 3]]);
                config.headers['Device-Id'] = deviceId;

       let stationA = 3.0;
       let rulesL = 0.0;
         stationA *= parseFloat(`${parseInt(`${rulesL}`)}`);
      if (2.45 > (stationA * rulesL)) {
          let statisticsG = 5.0;
          let leagueb = true;
          let bodang = true;
         rulesL /= Math.max((parseFloat(`${parseInt(`${statisticsG}`) ^ (bodang ? 1 : 1)}`)), 4);
         statisticsG += (1 / (Math.max((leagueb ? 2 : 1), 10)));
      }
      while (4.12 > rulesL) {
          let backwardd = String.fromCharCode(101,102,102,101,99,116,115,95,51,95,49,48,48,0);
          let mappingP = String.fromCharCode(104,95,54,49,95,112,114,111,112,0);
         rulesL /= Math.max(parseFloat(`${backwardd.length >> (Math.min(Math.abs(2), 4))}`), 3);
         backwardd += `${mappingP.length}`;
         mappingP = `${(String.fromCharCode(119,0) == mappingP ? mappingP.length : mappingP.length)}`;
         break;
      }
         stationA *= parseFloat(`${3}`);
      while (stationA <= rulesL) {
         rulesL *= parseFloat(`${parseInt(`${rulesL}`) % (Math.max(3, parseInt(`${stationA}`)))}`);
         break;
      }
      let filterU = 5312618.0 >= stationA;
      do {
         stationA -= parseFloat(`${parseInt(`${stationA}`) >> (Math.min(4, Math.abs(1)))}`);
         if (filterU) {
            break;
         }
      } while ((rulesL >= 5.18) && filterU);
      bodanm.push(3 >> (Math.min(Math.abs(parseInt(`${rulesL}`)), 2)));
                config.headers['Platform-OS'] = Platform.OS.toUpperCase();

   if (!anythinkc) {
      typingI.push(((anythinkc ? 4 : 1) - 2));
   }
                config.headers['App-Channel'] = UMENG_CHANNEL;

   let viewsB = anythinkc ? !anythinkc : anythinkc;
   do {
      anythinkc = String.fromCharCode(95,0) == crownu && 74 == streamingE.length;
      if (viewsB) {
         break;
      }
   } while (viewsB && (!anythinkc && 2 == champion2.length));
                config.headers['App-Name'] = encodeURIComponent(APP_NAME_CONST) + '-' + Platform.OS.toUpperCase();

       let hook7: Array<any> = [String.fromCharCode(116,114,97,110,115,113,117,97,110,116,95,111,95,53,50,0), String.fromCharCode(115,117,99,99,101,115,115,95,52,95,57,51,0)];
       let brightnessL = 4.0;
         brightnessL /= Math.max(3, hook7.length);
      let carouselF = 7092103 >= hook7.length;
      do {
          let modity_ = false;
          let matches4 = 2.0;
          let gpay7 = String.fromCharCode(110,95,54,53,95,109,105,110,115,0);
         hook7.push(parseInt(`${matches4}`));
         modity_ = !gpay7.startsWith(`${modity_}`);
         matches4 *= parseFloat(`${2 & gpay7.length}`);
         if (carouselF) {
            break;
         }
      } while (carouselF && (2 > hook7.length));
      for (let m = 0; m < 3; m++) {
         hook7.push(parseInt(`${brightnessL}`));
      }
      for (let j = 0; j < 2; j++) {
         hook7.push(parseInt(`${brightnessL}`));
      }
         brightnessL /= Math.max(hook7.length, 5);
      while (3.7 <= (5.49 + brightnessL)) {
         brightnessL += hook7.length * parseInt(`${brightnessL}`);
         break;
      }
      typingI = [2];
                config.headers['IP-Address'] = this.#getIpAddress();

   if ((short_s37 * 2) > 5.58) {
      acceptedc -= bodanM.size;
   }
                config.headers['App-Version'] = APP_VERSION;
            }

            return config;
        });
    }

    static get = (endpoint: string, {
        query,
        showErrorToast = false,
        isFullUrl = false,
    }: {
        query?: { [key: string]: any },
        showErrorToast?: boolean,
        isFullUrl?: boolean,
    } = {}): Promise<SMChatPlash> => {
        return this.#sendApiRequest(endpoint, {
            method: 'get',
            query,
            showErrorToast,
            isFullUrl,
        });
    }

    static post = (endpoint: string, {
        body,
        query,
        showErrorToast = false,
        isFullUrl = false,
    }: {
        body?: { [key: string]: any },
        query?: { [key: string]: any },
        showErrorToast?: boolean,
        isFullUrl?: boolean,
    } = {}): Promise<SMChatPlash> => {
        return this.#sendApiRequest(endpoint, {
            method: 'post',
            body,
            query,
            showErrorToast,
            isFullUrl,
        });
    }

    static put = (endpoint: string, {
        body,
        query,
        showErrorToast = false,
        isFullUrl = false,
    }: {
        body?: { [key: string]: any },
        query?: { [key: string]: any },
        showErrorToast?: boolean,
        isFullUrl?: boolean,
    } = {}): Promise<SMChatPlash> => {
        return this.#sendApiRequest(endpoint, {
            method: 'put',
            body,
            query,
            showErrorToast,
            isFullUrl,
        });
    }

    static patch = (endpoint: string, {
        body,
        query,
        showErrorToast = false,
        isFullUrl = false,
    }: {
        body?: { [key: string]: any },
        query?: { [key: string]: any },
        showErrorToast?: boolean,
        isFullUrl?: boolean,
    } = {}): Promise<SMChatPlash> => {
        return this.#sendApiRequest(endpoint, {
            method: 'patch',
            body,
            query,
            showErrorToast,
            isFullUrl,
        });
    }

    static delete = (endpoint: string, {
        query,
        showErrorToast = false,
        isFullUrl = false,
    }: {
        query?: { [key: string]: any },
        showErrorToast?: boolean,
        isFullUrl?: boolean,
    } = {}): Promise<SMChatPlash> => {
        return this.#sendApiRequest(endpoint, {
            method: 'delete',
            query,
            showErrorToast,
            isFullUrl,
        });
    }

    static #sendApiRequest = async (endpoint: string, {
        method = 'post',
        body,
        query,
        showErrorToast = false,
        isFullUrl = false,
    }: {
        method?: string,
        body?: { [key: string]: any },
        query?: { [key: string]: any },
        showErrorToast?: boolean,
        isFullUrl?: boolean,
    }): Promise<SMChatPlash> => {
        if (this.#apiInstance === null) {
            await this.init();
        }

        const url = isFullUrl ? endpoint : `${this.#env.apiUrl}/${endpoint}`;

        let response: AxiosResponse;

        switch (method.toLowerCase()) {
            case 'get':
                {
                    response = await this.#apiInstance!.get(url, {
                        params: query,
                    });
                    break;
                }
            case 'put':
                {
                    response = await this.#apiInstance!.put(url, body, {
                        params: query,
                    });
                    break;
                }
            case 'patch':
                {
                    response = await this.#apiInstance!.patch(url, body, {
                        params: query,
                    });
                    break;
                }
            case 'delete':
                {
                    response = await this.#apiInstance!.delete(url, {
                        params: query,
                    });
                    break;
                }
            case 'post':
            default:
                {
                    response = await this.#apiInstance!.post(url, body, {
                        params: query,
                    });
                }
        }

        const result: SMChatPlash = await this.#responseHandle(response, { isFullUrl });

        if (result.success == false && showErrorToast == true) {
            SMBing.showToast(result.message);
        }

        return result;
    }

    static #responseHandle = async (response: AxiosResponse, { isFullUrl = false }: { isFullUrl?: boolean, }): Promise<SMChatPlash> => {
        const responseBody: any = response.data;
        let result: { [key: string]: any } | undefined;
        let checker: Object | undefined;

        if (responseBody instanceof Object && !Array.isArray(responseBody)) {
            result = responseBody;
            checker = result as Object;
        }

        switch (response.status) {
            case 400:
                return new SMChatPlash({
                    statusCode: response.status,
                    success: false,
                    errors: result?.errors,
                    message: result?.message ?? WAnalyticsArrow.get(IHUpdateBanner.http400),
                });
            case 401:
                return new SMChatPlash({
                    statusCode: response.status,
                    success: false,
                    errors: result?.errors,
                    message: result?.message ?? WAnalyticsArrow.get(IHUpdateBanner.http401),
                });
            case 403:
                return new SMChatPlash({
                    statusCode: response.status,
                    success: false,
                    errors: result?.errors,
                    message: result?.message ?? WAnalyticsArrow.get(IHUpdateBanner.http403),
                });
            case 404:
                return new SMChatPlash({
                    statusCode: response.status,
                    success: false,
                    errors: result?.errors,
                    message: result?.message ?? WAnalyticsArrow.get(IHUpdateBanner.http404),
                });
            case 405:
                return new SMChatPlash({
                    statusCode: response.status,
                    success: false,
                    errors: result?.errors,
                    message: result?.message ?? WAnalyticsArrow.get(IHUpdateBanner.http405),
                });
            case 500:
                return new SMChatPlash({
                    statusCode: response.status,
                    success: false,
                    errors: result?.errors,
                    message: result?.message ?? WAnalyticsArrow.get(IHUpdateBanner.http500),
                });
            case 502:
                return new SMChatPlash({
                    statusCode: response.status,
                    success: false,
                    errors: result?.errors,
                    message: result?.message ?? WAnalyticsArrow.get(IHUpdateBanner.http502),
                });
            case 503:
                return new SMChatPlash({
                    statusCode: response.status,
                    success: false,
                    errors: result?.errors,
                    message: result?.message ?? WAnalyticsArrow.get(IHUpdateBanner.http503),
                });
            case 505:
                return new SMChatPlash({
                    statusCode: response.status,
                    success: false,
                    errors: result?.errors,
                    message: result?.message ?? WAnalyticsArrow.get(IHUpdateBanner.http505),
                });
            default:
                if (400 <= response.status && response.status <= 599) {
                    if (result !== undefined &&
                        checker!.hasOwnProperty('code') &&
                        result['code'] === -1
                    ) {
                        return new SMChatPlash({
                            statusCode: response.status ?? 400,
                            success: false,
                            message: result?.message ?? '',
                            data: result?.data,
                            errors: result?.errors,
                        });
                    }
                }
        }

        if (result !== undefined && checker!.hasOwnProperty('data')) {
            return new SMChatPlash({
                statusCode: response.status ?? 200,
                success: true,
                message: result?.message ?? '',
                data: result?.data,
            });
        }

        if (result !== undefined && isFullUrl) {
            return new SMChatPlash({
                statusCode: response.status ?? 200,
                success: true,
                message: '',
                data: result,
            });
        }

        return new SMChatPlash({
            statusCode: response.status ?? 200,
            success: true,
            message: result?.message ?? '',
        });
    }

    static regetToken = async (): Promise<string | null> => {
        this.bearerToken = await AsyncStorage.getItem("bearerToken") ?? '';
        return this.bearerToken;
    }

    static #getIpAddress = (): string => {
        return KLongNext.instance.ip;
    }
}

class SMChatPlash {
    statusCode: number;
    data: undefined | any | any[];
    errors: undefined | any | any[];
    success: boolean;
    message: string;

    constructor({
        statusCode,
        data,
        errors,
        success = true,
        message = '',
    }: {
        statusCode: number,
        data?: { [key: string]: any } | { [key: string]: any }[],
        errors?: { [key: string]: any } | { [key: string]: any }[],
        success?: boolean,
        message?: string,
    }) {
        this.statusCode = statusCode;
        this.data = data;
        this.errors = errors;
        this.success = success;
        this.message = message;
    }
}
