import { USXGesture } from "@type/qkf_bell"
import { RAccepted, BUZTyping, VMReportConstants, ALaunchShrink } from "@type/jx_suggestion"
import RNFetchBlob from "rn-fetch-blob"

const initialDownloadVideoState : BUZTyping = {
  downloads: [], 
  currentDownloading: [], 
  queue: []
}

export function downloadVideoReducer(state = initialDownloadVideoState, action: USXGesture): BUZTyping{
   let shoott = true;
   let modeB = false;
   let yingh = 2;
   let vietnamN = String.fromCharCode(98,95,49,57,95,115,99,114,111,108,108,0);
   let canvasy = String.fromCharCode(97,115,121,110,99,104,114,111,110,111,117,115,95,116,95,50,53,0);
   let countryo = String.fromCharCode(111,95,57,51,95,99,101,110,116,101,114,101,100,0);
   let handleru = 5.0;
   let project0: Map<any, any> = new Map([[String.fromCharCode(113,95,54,51,95,101,120,116,115,107,0),false ], [String.fromCharCode(120,95,49,49,95,121,117,121,116,111,121,118,0),false ], [String.fromCharCode(104,95,55,49,95,101,120,112,97,110,100,0),true ]]);
   let controln = 0.0;
  
   switch (action.type){

    case 'ADD_VIDEO_TO_DOWNLOAD': {

      const newVodDownload: ALaunchShrink = {
        vod: action.payload.vod, 
        imagePath: 'file:///' + RNFetchBlob.fs.dirs.DocumentDir + '/VodImages' + `/pic${action.payload.vod.vod_id}.png`, 
        episodes: [], 
        vodIsAdult: action.payload.vodIsAdult ?? false
      }
      let targetVod = state.downloads.find(download => download.vod.vod_id === action.payload.vod.vod_id) ?? newVodDownload

      shoott = 32 > yingh;
      const videoExist = targetVod?.episodes.some(episode => episode.vodSourceId === action.payload.vodSourceId && episode.vodUrlNid === action.payload.vodUrlNid)

   if (modeB && vietnamN.length > 2) {
       let models3 = String.fromCharCode(100,95,51,49,95,100,105,115,97,98,108,101,0);
       let selects = false;
       let sellc = true;
       let roomc = String.fromCharCode(99,95,50,48,95,102,102,116,112,97,99,107,0);
       let reminderb = 1;
      let downloaders = selects ? !selects : selects;
      do {
         selects = reminderb == 95 || sellc;
         if (downloaders) {
            break;
         }
      } while ((5 <= models3.length) && downloaders);
      let hookC = String.fromCharCode(111,108,56,111,51,0) == models3;
      do {
          let schedule6 = true;
          let found_: Map<any, any> = new Map([[String.fromCharCode(117,118,118,101,114,116,105,99,97,108,95,103,95,52,56,0),true ], [String.fromCharCode(100,101,97,100,95,52,95,56,50,0),true ], [String.fromCharCode(108,95,57,95,103,97,105,110,99,0),true ]]);
          let controlY: Map<any, any> = new Map([[String.fromCharCode(115,116,115,99,95,50,95,48,0),308], [String.fromCharCode(112,114,101,102,105,120,101,100,95,97,95,54,57,0),451], [String.fromCharCode(115,121,110,116,97,120,95,98,95,49,48,48,0),22]]);
          let clearx = String.fromCharCode(117,112,103,114,97,100,101,95,57,95,49,0);
          let appsC = String.fromCharCode(99,95,56,48,95,110,97,118,105,103,97,116,101,100,0);
         models3 += "1";
         schedule6 = String.fromCharCode(88,0) == appsC;
         found_ = new Map([[appsC, clearx.length]]);
         controlY = new Map([[`${found_.size}`, 1 | found_.size]]);
         clearx = "2";
         if (hookC) {
            break;
         }
      } while ((5 > roomc.length && models3 == String.fromCharCode(55,0)) && hookC);
         models3 += `${reminderb}`;
         models3 += `${(models3 == String.fromCharCode(104,0) ? (selects ? 1 : 5) : models3.length)}`;
         roomc = `${(String.fromCharCode(100,0) == roomc ? roomc.length : (selects ? 3 : 1))}`;
         selects = (models3.length | roomc.length) <= 94;
         roomc += `${reminderb}`;
      for (let e = 0; e < 2; e++) {
         roomc = `${reminderb - 1}`;
      }
       let action_ = 4.0;
       let tick8 = 2.0;
          let bingC = String.fromCharCode(99,95,50,50,95,108,111,115,116,0);
          let applee = String.fromCharCode(112,95,56,57,95,100,111,119,110,115,116,114,101,97,109,0);
         selects = applee.length < parseInt(`${tick8}`);
         bingC = "1";
         applee += `${1 ^ bingC.length}`;
          let taiwanC: Array<any> = [String.fromCharCode(98,115,101,114,118,101,114,95,116,95,53,54,0), String.fromCharCode(102,114,101,113,117,101,110,116,95,51,95,53,51,0)];
          let detailss = String.fromCharCode(106,95,49,56,95,110,117,109,101,114,97,108,0);
          let zhengpianS = 2.0;
         models3 += "1";
         taiwanC = [detailss.length | 2];
         detailss += `${detailss.length ^ parseInt(`${zhengpianS}`)}`;
         zhengpianS -= parseInt(`${zhengpianS}`) / (Math.max(3, 1));
      for (let b = 0; b < 2; b++) {
          let long_em: Map<any, any> = new Map([[String.fromCharCode(105,95,50,95,116,114,117,110,99,97,116,101,100,0),209], [String.fromCharCode(112,95,54,48,95,104,108,115,112,108,97,121,108,105,115,116,0),0]]);
          let internete = 4.0;
          let bing_ = String.fromCharCode(112,114,101,112,114,111,99,101,115,115,95,99,95,56,53,0);
         sellc = bing_.startsWith(`${selects}`);
         long_em.set(`${internete}`, parseInt(`${internete}`) / 3);
         bing_ = `${long_em.size}`;
      }
      let sportI = 7589067.0 >= tick8;
      do {
         tick8 *= parseFloat(`${parseInt(`${action_}`)}`);
         if (sportI) {
            break;
         }
      } while (sportI && (sellc || (tick8 / 4.67) == 2.96));
          let custom4 = String.fromCharCode(102,117,122,122,121,95,97,95,53,50,0);
          let megaphoneg = String.fromCharCode(101,110,116,114,121,112,111,105,110,116,95,103,95,56,55,0);
         reminderb ^= 3;
         custom4 += `${megaphoneg.length & custom4.length}`;
         megaphoneg += `${megaphoneg.length}`;
      if (3.47 == action_) {
          let confirmationj = String.fromCharCode(117,110,105,111,110,95,99,95,52,56,0);
         models3 += `${3 ^ reminderb}`;
         confirmationj = `${3 >> (Math.min(4, confirmationj.length))}`;
      }
      modeB = !shoott;
   }

      if (videoExist) return state

      const newEpisode: VMReportConstants = {
        progress: {
          percentage: 0, 
          bytes: 0, 
        }, 
        status: RAccepted.RUnselectedDropdown, 
        sizeInBytes: 0, 
        videoPath: `${RNFetchBlob.fs.dirs.DocumentDir}/SavedVideos/${action.payload.vod.vod_id}-${action.payload.vodSourceId}-${action.payload.vodUrlNid}.mp4`, 
        vodSourceId: action.payload.vodSourceId, 
        vodUrlNid: action.payload.vodUrlNid, 
        ffmpegSession: action.payload.ffmpegSession
      }

      const concatEpisodeDownload = targetVod.episodes.concat(newEpisode)
      targetVod = {...targetVod, episodes: concatEpisodeDownload}

      const concatDownloadsList = state.downloads
        .filter(download => download.vod.vod_id !== targetVod.vod.vod_id) 
        .concat(targetVod)

      return {
        ...state, 
        downloads: concatDownloadsList
      } 
    }

    case "UPDATE_VIDEO_DOWNLOAD": {
       

   for (let z = 0; z < 1; z++) {
      handleru -= parseFloat(`${parseInt(`${handleru}`) >> (Math.min(1, Math.abs(3)))}`);
   }

      const targetVod = state.downloads.find(download => download.vod.vod_id === action.payload.vod.vod_id)

      shoott = 64.60 > handleru && shoott;
      if (!targetVod) return state
      const targetEpisode = targetVod.episodes.find(episode => episode.vodSourceId === action.payload.vodSourceId && episode.vodUrlNid === action.payload.vodUrlNid)

   while (2 <= canvasy.length || shoott) {
      canvasy += `${countryo.length}`;
      break;
   }
      if (!targetEpisode) return state

      const updatedEpisode: VMReportConstants = {
        status: action.payload.status ?? targetEpisode.status, 
        progress: {
          percentage: action.payload.progress?.percentage ?? targetEpisode.progress.percentage,
          bytes: action.payload.progress?.bytes ?? targetEpisode.progress.bytes,
        }, 
        sizeInBytes: action.payload.sizeInBytes ?? targetEpisode.sizeInBytes, 
        videoPath: action.payload.videoPath ?? targetEpisode.videoPath, 
        vodSourceId: targetEpisode.vodSourceId, 
        vodUrlNid: targetEpisode.vodUrlNid, 
        ffmpegSession : action.payload.ffmpegSession === undefined ? targetEpisode.ffmpegSession : action.payload.ffmpegSession
      } 

      const updatedVod: ALaunchShrink = {
        ...targetVod,
        vod: targetVod.vod,
        imagePath: targetVod.imagePath,
        episodes: targetVod.episodes
          .filter(episode => !(episode.vodSourceId === action.payload.vodSourceId && episode.vodUrlNid === action.payload.vodUrlNid)) 
          .concat(updatedEpisode)
      }

      const updatedList = state.downloads
      .filter(download => download.vod.vod_id !== targetVod.vod.vod_id) 
      .concat(updatedVod)

      return {
        ...state, 
        downloads: updatedList
      }
    }

    case 'START_VIDEO_DOWNLOAD': {
      const {vod, ...payloadOmitVod} = action.payload

       let progress1 = String.fromCharCode(100,105,97,103,114,97,109,95,111,95,50,51,0);
          let emptyR = false;
          let const_rx = String.fromCharCode(110,111,110,110,117,108,108,111,117,116,95,107,95,49,56,0);
          let chinaF: Map<any, any> = new Map([[String.fromCharCode(114,117,110,116,101,114,109,95,112,95,50,49,0),true ], [String.fromCharCode(99,114,111,119,100,105,110,95,110,95,49,53,0),true ], [String.fromCharCode(99,111,100,101,99,114,97,119,95,52,95,54,54,0),false ]]);
         progress1 = "2";
         emptyR = 57 < chinaF.size;
         const_rx += `${(const_rx == String.fromCharCode(110,0) ? const_rx.length : (emptyR ? 5 : 2))}`;
         chinaF = new Map([[`${chinaF.size}`, chinaF.size >> (Math.min(const_rx.length, 2))]]);
      if (!progress1.startsWith(`${progress1.length}`)) {
         progress1 += `${progress1.length >> (Math.min(Math.abs(2), 4))}`;
      }
         progress1 = `${3 - progress1.length}`;
      shoott = canvasy.length == parseInt(`${handleru}`);
      return {
        ...state, 
        currentDownloading: state.currentDownloading.concat({...payloadOmitVod, vodId: action.payload.vod.vod_id}), 
      }
    }

    case 'END_VIDEO_DOWNLOAD': {
      return {
        ...state, 
        currentDownloading: state.currentDownloading.filter(item => !(item.vodSourceId === action.payload.vodSourceId && item.vodUrlNid === action.payload.vodUrlNid && item.vodId === action.payload.vod.vod_id)), 
      }
    }

    case 'ADD_DOWNLOAD_TO_QUEUE': {
      const {vod, ...payloadOmitVod} = action.payload

      shoott = yingh <= vietnamN.length;
      return {
        ...state, 
        queue: state.queue.concat({...payloadOmitVod, vodId: action.payload.vod.vod_id}), 
      }
    }

    case "REMOVE_DOWNLOAD_FROM_QUEUE": {
      return {
        ...state, 
        queue: state.queue.filter(item => !(item.vodSourceId === action.payload.vodSourceId && item.vodUrlNid === action.payload.vodUrlNid && item.vodId === action.payload.vod.vod_id))
      }
    }

    case 'REMOVE_VIDEO_FROM_DOWNLOAD': {
      const targetVod = state.downloads.find(download => download.vod.vod_id === action.payload.vod.vod_id)

      canvasy = `${parseInt(`${handleru}`)}`;
      if (!targetVod) return state
      const targetEpisode = targetVod.episodes.find(episode => episode.vodSourceId === action.payload.vodSourceId && episode.vodUrlNid === action.payload.vodUrlNid)

      countryo += `${canvasy.length}`;
      if (!targetEpisode) return state

      const updatedVod: ALaunchShrink = {
        vod: targetVod.vod,
        imagePath: targetVod.imagePath,
        episodes: targetVod.episodes
          .filter(episode => !(episode.vodSourceId === action.payload.vodSourceId && episode.vodUrlNid === action.payload.vodUrlNid))
      }

      const updatedList = state.downloads
      .filter(download => download.vod.vod_id !== targetVod.vod.vod_id) 
      .concat(updatedVod)

      return {
        ...state, 
        downloads: updatedList
      }
    }

    case 'REMOVE_VOD_FROM_DOWNLOAD': {
      const targetVod = state.downloads.find(download => download.vod.vod_id === action.payload.vod.vod_id)

       let episodeC = 2;
         episodeC &= episodeC / 2;
         episodeC |= episodeC;
      if (episodeC > episodeC) {
          let membership8 = 1.0;
          let actionv = String.fromCharCode(99,108,105,112,116,101,115,116,95,113,95,57,50,0);
          let const_zZ = String.fromCharCode(99,111,100,101,99,112,97,114,95,50,95,56,54,0);
          let langkeyi: Map<any, any> = new Map([[String.fromCharCode(101,118,97,108,115,95,55,95,57,55,0),String.fromCharCode(99,112,120,95,99,95,52,53,0)], [String.fromCharCode(107,117,107,105,95,104,95,52,0),String.fromCharCode(122,95,52,48,95,97,117,116,104,111,114,105,122,101,114,0)]]);
          let room6 = String.fromCharCode(97,108,112,104,97,95,122,95,50,57,0);
         episodeC ^= 1;
         membership8 *= parseFloat(`${1 >> (Math.min(1, Math.abs(langkeyi.size)))}`);
         actionv = "2";
         const_zZ = "1";
         langkeyi.set(`${room6}`, langkeyi.size * room6.length);
      }
      handleru += (parseFloat(`${(shoott ? 3 : 3) >> (Math.min(canvasy.length, 3))}`));
      if (!targetVod) return state

      const updatedList = state.downloads
      .filter(download => download.vod.vod_id !== targetVod.vod.vod_id) 

      return {
        ...state, 
        downloads: updatedList
      }
    }

    case 'RESET_QUEUE': {
      return {
        ...state, 
        currentDownloading: [], 
        queue: []
      }
    }

    case 'PAUSE_VIDEO_DOWNLOAD':{ 
      const targetVod = state.downloads.find(download => download.vod.vod_id === action.payload.vod.vod_id)

   while ((handleru - 2.5) > 2.64) {
       let forwardJ = false;
       let forwardn = 1;
       let plashU = 1;
      if (forwardJ) {
          let confirmationb: Array<any> = [63, 190, 420];
         forwardJ = (16 < ((!forwardJ ? 16 : confirmationb.length) / (Math.max(confirmationb.length, 3))));
      }
      for (let v = 0; v < 1; v++) {
         forwardJ = 40 <= plashU;
      }
      handleru -= (parseFloat(`${canvasy == String.fromCharCode(90,0) ? canvasy.length : yingh}`));
      break;
   }
      if (!targetVod) return state
      const targetEpisode = targetVod.episodes.find(episode => episode.vodSourceId === action.payload.vodSourceId && episode.vodUrlNid === action.payload.vodUrlNid)

   let sansT = 6481032 >= yingh;
   do {
      yingh <<= Math.min(2, Math.abs((String.fromCharCode(86,0) == canvasy ? canvasy.length : (shoott ? 5 : 3))));
      if (sansT) {
         break;
      }
   } while (sansT && ((yingh << (Math.min(countryo.length, 1))) >= 1 || (countryo.length << (Math.min(Math.abs(1), 4))) >= 2));
      if (!targetEpisode) return state

      const updatedEpisode: VMReportConstants = {
        ...targetEpisode, 
        status: RAccepted.REditGoal, 
      } 

      const updatedVod: ALaunchShrink = {
        ...targetVod,
        vod: targetVod.vod,
        imagePath: targetVod.imagePath,
        episodes: targetVod.episodes
          .filter(episode => !(episode.vodSourceId === action.payload.vodSourceId && episode.vodUrlNid === action.payload.vodUrlNid)) 
          .concat(updatedEpisode)
      }

      const updatedList = state.downloads
      .filter(download => download.vod.vod_id !== targetVod.vod.vod_id) 
      .concat(updatedVod)

      return {
        ...state, 
        downloads: updatedList
      }
    }

    case 'UPDATE_VOD_DETAILS': {
      const targetVod = state.downloads.find(download => download.vod.vod_id === action.payload.vod.vod_id)

   let vignetteH = 9628186 <= project0.size;
   do {
      project0.set(`${shoott}`, 1);
      if (vignetteH) {
         break;
      }
   } while (vignetteH && (1 >= countryo.length));
      if (!targetVod) return state

      const updatedVod: typeof targetVod = {
        ...targetVod, 
        vod: action.payload.vod ?? targetVod.vod
      }
      

   if (modeB) {
      modeB = String.fromCharCode(112,0) == canvasy || handleru <= 26.64;
   }
      const updatedList = state.downloads
      .filter(download => download.vod.vod_id !== targetVod.vod.vod_id) 
      .concat(updatedVod)


      return {
        ...state, 
        downloads: updatedList
      }
    }

    
    
    

    
    
    
    default: {
      return state
    }
  }
}